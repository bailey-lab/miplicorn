#------------------------------------------------
#' Read MIPTools tables
#'
#' @description
#' The `read_tbl_*()` family of functions is designed to read data tables
#' generated by the software program
#' [`MIPtools`](https://github.com/bailey-lab/MIPTools). Data is read lazily
#' using the [`vroom` package](https://vroom.r-lib.org/index.html). Data can be
#' filtered, retaining all rows that satisfy the conditions. To be retained, the
#' row in question must produce a value of `TRUE` for all conditions. Note that
#' when a condition evaluates to NA, the row will be dropped.
#'
#' @section Data structure:
#' Input data must contain six rows of metadata. The metadata can vary depending
#' on what type of file is read, but typically contains information about the
#' location of a mutation. The remaining rows represent the data for each sample
#' sequenced. Together, the alternate, reference, and coverage tables can
#' provide information about mutations observed and the coverage at each site.
#'
#' @section Useful filter functions:
#' The `dplyr::filter()` function is employed to subset the rows of the data
#' applying the expressions in `...` to the column values to determine which
#' rows should be retained.
#'
#' There are many functions and operators that are useful when constructing the
#' expressions used to filter the data:
#'
#' * [`==`], [`>`], [`>=`], etc.
#' * [`&`], [`|`], [`!`], [xor()]
#' * [is.na()]
#' * [between()], [near()]
#'
#' @param .tbl File path to the table.
#' @param ... <[`data-masking`][dplyr_data_masking]> Expressions that return a
#'   logical value and are used to filter the data. If multiple expressions are
#'   included, they are combined with the `&` operator. Only rows for which all
#'   conditions evaluate to `TRUE` are kept.
#' @param .tbl_ref File path to the reference table.
#' @param .tbl_alt File path to the alternate table.
#' @param .tbl_cov File path to the coverage table.
#' @param chrom `r lifecycle::badge("deprecated")` The chromosome(s) to filter
#'   to.
#' @param gene `r lifecycle::badge("deprecated")` The gene(s) to filter to.
#'
#' @return A [tibble()]. The first six columns contain the metadata associated
#' with each sample and mutation. The last column contains the information
#' parsed from the table. In some cases, this may be the umi_count and in other
#' cases it may be the coverage of the associated data point.
#'
#' @seealso [vroom::vroom()] [dplyr::filter()]
#' @name read-tbl
#' @examples
#' # Get path to example file
#' ref_file <- miplicorn_example("reference_AA_table.csv")
#' alt_file <- miplicorn_example("alternate_AA_table.csv")
#' cov_file <- miplicorn_example("coverage_AA_table.csv")
#' ref_file
#'
#' # Input sources -------------------------------------------------------------
#' # Read from a path
#' read_tbl_reference(ref_file)
#'
#' # You can also use paths directly
#' # read_tbl_alternate("alternate_AA_table.csv")
#'
#' # Read entire file ----------------------------------------------------------
#' read_tbl_coverage(cov_file)
#'
#' # Data filtering ------------------------------------------------------------
#' # Filtering by one criterion
#' read_tbl_reference(ref_file, gene == "atp6")
#'
#' # Filtering by multiple criteria within a single logical expression
#' read_tbl_alternate(alt_file, gene == "atp6" & targeted == "Yes")
#' read_tbl_coverage(cov_file, gene == "atp6" | targeted == "Yes")
#'
#' # When multiple expressions are used, they are combined using &
#' read_tbl_reference(ref_file, gene == "atp6", targeted == "Yes")
#'
#' # Read multiple files together ----------------------------------------------
#' read_tbl_ref_alt_cov(ref_file, alt_file, cov_file)
NULL

#' @rdname read-tbl
#' @export
read_tbl_reference <- function(.tbl, ...) {
  read_tbl_helper(.tbl, ..., .name = "ref_umi_count")
}

#' @rdname read-tbl
#' @export
read_tbl_alternate <- function(.tbl, ...) {
  read_tbl_helper(.tbl, ..., .name = "alt_umi_count")
}

#' @rdname read-tbl
#' @export
read_tbl_coverage <- function(.tbl, ...) {
  read_tbl_helper(.tbl, ..., .name = "coverage")
}

#' @rdname read-tbl
#' @export
read_tbl_ref_alt_cov <- function(.tbl_ref,
                                 .tbl_alt,
                                 .tbl_cov,
                                 ...,
                                 chrom = deprecated(),
                                 gene = deprecated()) {
  # Deprecated chrom
  if (lifecycle::is_present(chrom)) {
    lifecycle::deprecate_warn(
      when = "0.1.0",
      what = "read(chrom)",
      details = "Please use the `...` argument instead to filter data."
    )
  }

  # Deprecated gene
  if (lifecycle::is_present(gene)) {
    lifecycle::deprecate_warn(
      when = "0.1.0",
      what = "read(gene)",
      details = "Please use the `...` argument instead to filter data."
    )
  }

  # Error message if multiple criteria selected
  if (lifecycle::is_present(chrom) && lifecycle::is_present(gene)) {
    abort(c(
      "Multiple filtering criteria selected.",
      x = "Cannot filter on both `chrom` and `gene`.",
      i = "Select only one piece of information to filter on."
    ))
  }

  # Error if any file is empty
  if (purrr::some(list(.tbl_ref, .tbl_alt, .tbl_cov), empty_file)) {
    empty <- purrr::detect(list(.tbl_ref, .tbl_alt, .tbl_cov), empty_file)
    abort(c(
      "Unable to read files.",
      x = glue('"{empty}" is an empty file.')
    ))
  }

  # Read in the three files
  if (lifecycle::is_present(chrom) || lifecycle::is_present(gene)) {
    tables <- purrr::pmap(
      list(
        file = c(.tbl_ref, .tbl_alt, .tbl_cov),
        name = c("ref_umi_count", "alt_umi_count", "coverage")
      ),
      deprec_read_file,
      chrom = chrom,
      gene = gene
    )
  } else {
    tables <- purrr::pmap(
      list(
        .tbl = c(.tbl_ref, .tbl_alt, .tbl_cov),
        .name = c("ref_umi_count", "alt_umi_count", "coverage")
      ),
      read_tbl_helper,
      ...
    )
  }

  # Determine overlapping columns
  by <- purrr::reduce(purrr::map(tables, colnames), intersect)

  # Combine three tibbles together
  purrr::reduce(tables, dplyr::full_join, by = by)
}

# Helper function used to read reference, alternate, and coverage tables
read_tbl_helper <- function(.tbl, ..., .name = "value") {
  dots <- enquos(..., .ignore_empty = "all")
  check_named(dots)

  if (empty_file(.tbl)) {
    return(tibble::tibble())
  }

  # Read in complete header
  header <- .tbl %>%
    vroom::vroom(col_names = FALSE, show_col_types = FALSE, n_max = 6) %>%
    tibble::rownames_to_column() %>%
    tidyr::pivot_longer(-.data$rowname) %>%
    tidyr::pivot_wider(
      names_from = .data$rowname,
      values_from = .data$value
    ) %>%
    janitor::row_to_names(1) %>%
    janitor::clean_names()

  # Filter the header based on conditions specified
  tryCatch(
    filter_header <- dplyr::filter(header, ...),
    error = function(e) {
      e <- rlang::catch_cnd(dplyr::filter(header, ...))
      msg <- e$message %>%
        stringr::str_replace_all(c(
          "filter" = "read_tbl_*()",
          "comparison" = "Comparison"
        )) %>%
        stringr::str_c(".")
      objects <- stringr::str_c("'", colnames(header)[-1], "'")
      abort(c(
        msg,
        i = cli::pluralize("Available objects are {objects}.")
      ))
    }
  )

  # Extract which columns of data we are interested in
  col_select <- filter_header[[1]] %>%
    stringr::str_extract("\\d+") %>%
    as.numeric()

  # Read in entire data set but select only columns we are interested in
  data <- vroom::vroom(
    file = .tbl,
    col_names = FALSE,
    col_select = c(1, col_select),
    show_col_types = FALSE,
    .name_repair = "universal"
  )

  # Take the transpose of our matrix, making rows columns and columns rows
  t_data <- data %>%
    tibble::rownames_to_column() %>%
    tidyr::pivot_longer(-.data$rowname) %>%
    tidyr::pivot_wider(
      names_from = .data$rowname,
      values_from = .data$value
    ) %>%
    # Assign the column names of our tibble and clean them up
    dplyr::select(-.data$name) %>%
    janitor::row_to_names(1) %>%
    janitor::clean_names()

  # Convert our data to a long format
  t_data %>%
    tidyr::pivot_longer(
      cols = -c(1:6),
      names_to = "sample",
      values_to = "value"
    ) %>%
    dplyr::relocate(sample) %>%
    dplyr::mutate(value = as.numeric(.data$value)) %>%
    dplyr::rename({{ .name }} := .data$value)
}

# Check named arguments for filtering step
check_named <- function(dots) {
  named <- rlang::have_name(dots)

  for (i in which(named)) {
    quo <- dots[[i]]

    # Only allow unnamed logical vectors, anything else is suspicious
    expr <- rlang::quo_get_expr(quo)
    if (!rlang::is_logical(expr)) {
      name <- names(dots)[i]
      abort(c(
        glue("Problem with `read_tbl_*()` input `..{i}`."),
        x = glue("Input `..{i}` is named."),
        i = "This usually means that you've used `=` instead of `==`.",
        i = glue("Did you mean `{name} == {as_label(expr)}`?")
      ))
    }
  }
}
